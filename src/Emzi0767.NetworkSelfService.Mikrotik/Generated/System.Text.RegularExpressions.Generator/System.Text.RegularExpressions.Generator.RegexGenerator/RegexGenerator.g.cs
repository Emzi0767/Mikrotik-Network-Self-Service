// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used

namespace Emzi0767.NetworkSelfService.Mikrotik.Types
{
    partial struct MacAddress
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>^[0-9a-fA-F]{2}(?&lt;sep&gt;[:\\-])?(?(sep)(?:[0-9a-fA-F]{2}\\k&lt;sep&gt;){4}|(?:[0-9a-fA-F]{2}){4})[0-9a-fA-F]{2}$</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Compiled</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at the beginning of the string.<br/>
        /// ○ Match a character in the set [0-9A-Fa-f] exactly 2 times.<br/>
        /// ○ Optional (greedy).<br/>
        ///     ○ "sep" capture group.<br/>
        ///         ○ Match a character in the set [-:].<br/>
        /// ○ Conditionally match one of two expressions depending on whether the "sep" capture group matched.<br/>
        ///     ○ Matched: Loop exactly 4 times.<br/>
        ///         ○ Match a character in the set [0-9A-Fa-f] exactly 2 times.<br/>
        ///         ○ Match the same text as matched by the "sep" capture group.<br/>
        ///     ○ Not Matched: Loop exactly 4 times.<br/>
        ///         ○ Match a character in the set [0-9A-Fa-f] exactly 2 times.<br/>
        /// ○ Match a character in the set [0-9A-Fa-f] exactly 2 times.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.11.1707")]
        private static partial global::System.Text.RegularExpressions.Regex MacRegexGen() => global::System.Text.RegularExpressions.Generated.MacRegexGen_0.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the MacRegexGen method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.11.1707")]
    file sealed class MacRegexGen_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly MacRegexGen_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private MacRegexGen_0()
        {
            base.pattern = "^[0-9a-fA-F]{2}(?<sep>[:\\-])?(?(sep)(?:[0-9a-fA-F]{2}\\k<sep>){4}|(?:[0-9a-fA-F]{2}){4})[0-9a-fA-F]{2}$";
            base.roptions = RegexOptions.Compiled;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.CapNames = new Hashtable { { "0", 0 } ,  { "sep", 1 }  };
            base.capslist = new string[] {"0", "sep" };
            base.capsize = 2;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // The pattern is anchored.  Validate the current position and try to match at it only.
                    if (TryFindNextPossibleStartingPosition(inputSpan) && !TryMatchAtCurrentPosition(inputSpan))
                    {
                        base.runtextpos = inputSpan.Length;
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 12 characters.
                    if (pos <= inputSpan.Length - 12)
                    {
                        // The pattern leads with a beginning (\A) anchor.
                        if (pos == 0)
                        {
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    int loop_iteration = 0;
                    int matchLength = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at the beginning of the string.
                    if (pos != 0)
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // Match a character in the set [0-9A-Fa-f] exactly 2 times.
                    {
                        if ((uint)slice.Length < 2 ||
                            !char.IsAsciiHexDigit(slice[0]) ||
                            !char.IsAsciiHexDigit(slice[1]))
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                    }
                    
                    // Optional (greedy).
                    //{
                        pos += 2;
                        slice = inputSpan.Slice(pos);
                        loop_iteration = 0;
                        
                        LoopBody:
                        Utilities.StackPush(ref base.runstack!, ref stackpos, base.Crawlpos(), pos);
                        
                        loop_iteration++;
                        
                        // "sep" capture group.
                        {
                            int capture_starting_pos = pos;
                            
                            // Match a character in the set [-:].
                            if (slice.IsEmpty || (((ch = slice[0]) != '-') & (ch != ':')))
                            {
                                goto LoopIterationNoMatch;
                            }
                            
                            pos++;
                            slice = inputSpan.Slice(pos);
                            base.Capture(1, capture_starting_pos, pos);
                        }
                        
                        
                        // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                        if (loop_iteration == 0)
                        {
                            goto LoopBody;
                        }
                        goto LoopEnd;
                        
                        // The loop iteration failed. Put state back to the way it was before the iteration.
                        LoopIterationNoMatch:
                        if (--loop_iteration < 0)
                        {
                            // Unable to match the remainder of the expression after exhausting the loop.
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                        pos = base.runstack![--stackpos];
                        UncaptureUntil(base.runstack![--stackpos]);
                        slice = inputSpan.Slice(pos);
                        LoopEnd:;
                    //}
                    
                    // Conditionally match one of two expressions depending on whether the "sep" capture group matched.
                    {
                        if (base.IsMatched(1))
                        {
                            // The "sep" capture group captured a value.  Match the first branch.
                            // Loop exactly 4 times.
                            {
                                for (int loop_iteration1 = 0; loop_iteration1 < 4; loop_iteration1++)
                                {
                                    // Match a character in the set [0-9A-Fa-f] exactly 2 times.
                                    {
                                        if ((uint)slice.Length < 2 ||
                                            !char.IsAsciiHexDigit(slice[0]) ||
                                            !char.IsAsciiHexDigit(slice[1]))
                                        {
                                            goto LoopIterationNoMatch;
                                        }
                                    }
                                    
                                    // Match the same text as matched by the "sep" capture group.
                                    {
                                        pos += 2;
                                        slice = inputSpan.Slice(pos);
                                        
                                        // If the "sep" capture group hasn't matched, the backreference doesn't match.
                                        if (!base.IsMatched(1))
                                        {
                                            goto LoopIterationNoMatch;
                                        }
                                        
                                        // Get the captured text.  If it doesn't match at the current position, the backreference doesn't match.
                                        matchLength = base.MatchLength(1);
                                        if (slice.Length < matchLength || 
                                            !inputSpan.Slice(base.MatchIndex(1), matchLength).SequenceEqual(slice.Slice(0, matchLength)))
                                        {
                                            goto LoopIterationNoMatch;
                                        }
                                        
                                        pos += matchLength;
                                        slice = inputSpan.Slice(pos);
                                    }
                                }
                            }
                            
                        }
                        else
                        {
                            // Otherwise, match the second branch.
                            // Loop exactly 4 times.
                            {
                                for (int loop_iteration2 = 0; loop_iteration2 < 4; loop_iteration2++)
                                {
                                    // Match a character in the set [0-9A-Fa-f] exactly 2 times.
                                    {
                                        if ((uint)slice.Length < 2 ||
                                            !char.IsAsciiHexDigit(slice[0]) ||
                                            !char.IsAsciiHexDigit(slice[1]))
                                        {
                                            goto LoopIterationNoMatch;
                                        }
                                    }
                                    pos += 2;
                                    slice = inputSpan.Slice(pos);
                                }
                            }
                            
                        }
                    }
                    
                    // Match a character in the set [0-9A-Fa-f] exactly 2 times.
                    {
                        if ((uint)slice.Length < 2 ||
                            !char.IsAsciiHexDigit(slice[0]) ||
                            !char.IsAsciiHexDigit(slice[1]))
                        {
                            goto LoopIterationNoMatch;
                        }
                    }
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (3 < slice.Length || (2 < slice.Length && slice[2] != '\n'))
                    {
                        goto LoopIterationNoMatch;
                    }
                    
                    // The input matched.
                    pos += 2;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.11.1707")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
        
        /// <summary>Pushes 2 values onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0, int arg1)
        {
            // If there's space available for all 2 values, store them.
            int[] s = stack;
            int p = pos;
            if ((uint)(p + 1) < (uint)s.Length)
            {
                s[p] = arg0;
                s[p + 1] = arg1;
                pos += 2;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0, arg1);
        
            // <summary>Resize the backtracking stack array and push 2 values onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0, int arg1)
            {
                Array.Resize(ref stack, (pos + 1) * 2);
                StackPush(ref stack, ref pos, arg0, arg1);
            }
        }
    }
}
